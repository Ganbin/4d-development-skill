#!/usr/bin/env python3
"""
Index generator for 4D v21 skill documentation.

Parses docs/ directory and generates structured index files in references/.
Each index file provides a navigable map of one documentation category.

Usage:
    python scripts/generate-indexes.py [--docs-dir PATH] [--output-dir PATH]

Defaults:
    --docs-dir: docs/ (relative to script's parent directory)
    --output-dir: references/ (relative to script's parent directory)
"""

import os
import re
import sys
import argparse
from pathlib import Path
from collections import defaultdict

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def parse_frontmatter(filepath: Path) -> dict:
    """Extract YAML frontmatter fields from a markdown file."""
    result = {}
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            content = f.read()
    except Exception:
        return result

    match = re.match(r"^---\s*\n(.*?)\n---", content, re.DOTALL)
    if not match:
        return result

    for line in match.group(1).splitlines():
        m = re.match(r"^(\w[\w_-]*):\s*(.+)$", line.strip())
        if m:
            result[m.group(1)] = m.group(2).strip().strip('"').strip("'")
    return result


def get_first_description(filepath: Path, max_chars=120) -> str:
    """Get the first meaningful line after frontmatter as a brief description."""
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            content = f.read()
    except Exception:
        return ""

    # Strip frontmatter
    content = re.sub(r"^---\s*\n.*?\n---\s*\n?", "", content, flags=re.DOTALL)

    # Strip HTML comments
    content = re.sub(r"<!--.*?-->", "", content, flags=re.DOTALL)

    for line in content.splitlines():
        line = line.strip()
        # Skip empty, headings, table separators, images, includes
        if not line or line.startswith("#") or line.startswith("|") or \
           line.startswith("![") or line.startswith("```") or \
           line.startswith(":::") or line.startswith(">"):
            continue
        # Clean markdown formatting
        line = re.sub(r"\*\*(.+?)\*\*", r"\1", line)
        line = re.sub(r"\[(.+?)\]\(.+?\)", r"\1", line)
        line = line.strip()
        if len(line) > 10:
            return line[:max_chars] + ("..." if len(line) > max_chars else "")
    return ""


def extract_api_methods(filepath: Path) -> list[str]:
    """Extract method/function names from an API class file."""
    methods = []
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            content = f.read()
    except Exception:
        return methods

    # Pattern 1: Summary table anchors like (#methodname)
    for m in re.finditer(r"\]\(#(\w+)\)", content):
        name = m.group(1)
        if name not in methods and name.lower() != "summary":
            methods.append(name)

    # Pattern 2: ## headings like "## .methodName()" or "## methodName"
    if not methods:
        for m in re.finditer(r"^##\s+\.?(\w+)\s*\(", content, re.MULTILINE):
            name = m.group(1)
            if name not in methods:
                methods.append(name)

    return methods


def extract_command_names_from_theme(filepath: Path) -> list[tuple[str, str]]:
    """Extract command references from a theme file. Returns [(command_name, link_path)]."""
    commands = []
    try:
        with open(filepath, "r", encoding="utf-8") as f:
            content = f.read()
    except Exception:
        return commands

    # Pattern: <!-- INCLUDE #_command_.CommandName.Syntax --> linked to (path.md)
    for m in re.finditer(
        r"INCLUDE\s+#_command_\.(.+?)\.Syntax.*?\]\((.+?\.md)\)", content
    ):
        cmd_name = m.group(1).replace("_", " ")
        link = m.group(2)
        commands.append((cmd_name, link))

    return commands


def relative_doc_path(filepath: Path, docs_dir: Path) -> str:
    """Get the docs/ relative path for display."""
    return "docs/" + str(filepath.relative_to(docs_dir))


def get_md_files(directory: Path) -> list[Path]:
    """Get sorted list of .md files in a directory (non-recursive)."""
    if not directory.exists():
        return []
    return sorted(directory.glob("*.md"))


def count_files_recursive(directory: Path) -> int:
    """Count all .md files recursively in a directory."""
    if not directory.exists():
        return 0
    return len(list(directory.rglob("*.md")))


# ---------------------------------------------------------------------------
# Index generators
# ---------------------------------------------------------------------------

HEADER = (
    "<!-- Auto-generated by scripts/generate-indexes.py — Do not edit manually -->\n"
    "<!-- Re-generate: python scripts/generate-indexes.py -->\n\n"
)


def generate_api_index(docs_dir: Path, output_dir: Path):
    """Generate api-index.md from docs/API/."""
    api_dir = docs_dir / "API"
    files = get_md_files(api_dir)
    if not files:
        return

    lines = [HEADER, "# API Classes Index\n\n"]
    lines.append(f"> {len(files)} class reference files in `docs/API/`\n\n")
    lines.append("| Class | File | Key Methods |\n")
    lines.append("|-------|------|-------------|\n")

    for fp in files:
        fm = parse_frontmatter(fp)
        title = fm.get("title", fp.stem)
        rel_path = relative_doc_path(fp, docs_dir)
        methods = extract_api_methods(fp)
        methods_str = ", ".join(f".{m}()" for m in methods[:12])
        if len(methods) > 12:
            methods_str += f", ... (+{len(methods) - 12} more)"
        lines.append(f"| {title} | `{rel_path}` | {methods_str} |\n")

    (output_dir / "api-index.md").write_text("".join(lines), encoding="utf-8")
    print(f"  Generated api-index.md ({len(files)} classes)")


def generate_commands_index(docs_dir: Path, output_dir: Path):
    """Generate commands-index.md from docs/commands/ and docs/commands/theme/."""
    cmd_dir = docs_dir / "commands"
    theme_dir = cmd_dir / "theme"

    lines = [HEADER, "# Commands Index\n\n"]

    # Modern commands (direct files in commands/)
    cmd_files = [f for f in get_md_files(cmd_dir) if f.name != "command-index.md"]
    lines.append(f"## Modern Commands ({len(cmd_files)} files)\n\n")
    lines.append("> Files in `docs/commands/`\n\n")
    lines.append("| Command | File | Description |\n")
    lines.append("|---------|------|-------------|\n")

    for fp in cmd_files:
        fm = parse_frontmatter(fp)
        title = fm.get("title", fp.stem)
        rel_path = relative_doc_path(fp, docs_dir)
        desc = get_first_description(fp, 80)
        lines.append(f"| {title} | `{rel_path}` | {desc} |\n")

    # Theme index
    if theme_dir.exists():
        theme_files = get_md_files(theme_dir)
        lines.append(f"\n## Command Themes ({len(theme_files)} categories)\n\n")
        lines.append("> Files in `docs/commands/theme/` — each lists related commands\n\n")
        lines.append("| Theme | File | Commands |\n")
        lines.append("|-------|------|----------|\n")

        for fp in theme_files:
            fm = parse_frontmatter(fp)
            title = fm.get("title", fp.stem.replace("_", " "))
            rel_path = relative_doc_path(fp, docs_dir)
            cmds = extract_command_names_from_theme(fp)
            cmd_names = ", ".join(c[0] for c in cmds[:8])
            if len(cmds) > 8:
                cmd_names += f", ... (+{len(cmds) - 8} more)"
            lines.append(f"| {title} | `{rel_path}` | {cmd_names} |\n")

    (output_dir / "commands-index.md").write_text("".join(lines), encoding="utf-8")
    print(f"  Generated commands-index.md ({len(cmd_files)} commands, "
          f"{len(get_md_files(theme_dir)) if theme_dir.exists() else 0} themes)")


def generate_simple_index(
    docs_dir: Path,
    output_dir: Path,
    category_dir: str,
    output_name: str,
    title: str,
    description: str = "",
):
    """Generate a simple index for a flat directory of docs."""
    target_dir = docs_dir / category_dir
    files = get_md_files(target_dir)
    if not files:
        print(f"  Skipped {output_name} (no files in docs/{category_dir}/)")
        return

    lines = [HEADER, f"# {title}\n\n"]
    if description:
        lines.append(f"> {description}\n\n")
    lines.append(f"> {len(files)} files in `docs/{category_dir}/`\n\n")
    lines.append("| Title | File | Description |\n")
    lines.append("|-------|------|-------------|\n")

    for fp in files:
        fm = parse_frontmatter(fp)
        doc_title = fm.get("title", fp.stem)
        rel_path = relative_doc_path(fp, docs_dir)
        desc = get_first_description(fp, 100)
        lines.append(f"| {doc_title} | `{rel_path}` | {desc} |\n")

    (output_dir / output_name).write_text("".join(lines), encoding="utf-8")
    print(f"  Generated {output_name} ({len(files)} files)")


def generate_legacy_commands_index(docs_dir: Path, output_dir: Path):
    """Generate legacy-commands-index.md organized by theme."""
    legacy_dir = docs_dir / "commands-legacy"
    theme_dir = docs_dir / "commands" / "theme"

    if not legacy_dir.exists():
        return

    all_legacy = get_md_files(legacy_dir)
    lines = [HEADER, "# Legacy Commands Index\n\n"]
    lines.append(f"> {len(all_legacy)} legacy command files in `docs/commands-legacy/`\n\n")
    lines.append("These commands are from older 4D versions. Many have modern equivalents.\n")
    lines.append("Use grep to find specific commands:\n")
    lines.append("```\ngrep -r \"title: COMMAND NAME\" docs/commands-legacy/\n```\n\n")

    # Build theme-to-commands mapping from theme files
    if theme_dir.exists():
        theme_files = get_md_files(theme_dir)
        lines.append("## By Theme\n\n")

        for tf in theme_files:
            fm = parse_frontmatter(tf)
            theme_title = fm.get("title", tf.stem.replace("_", " "))
            cmds = extract_command_names_from_theme(tf)
            if cmds:
                lines.append(f"### {theme_title}\n\n")
                for cmd_name, link in cmds:
                    # Resolve the relative link to a docs/ path
                    if "../../commands-legacy/" in link:
                        resolved = link.replace("../../commands-legacy/", "docs/commands-legacy/")
                    elif "../../commands/" in link:
                        resolved = link.replace("../../commands/", "docs/commands/")
                    else:
                        resolved = f"docs/commands-legacy/{Path(link).name}"
                    # Verify path exists, try alternate location if not
                    if not (docs_dir.parent / resolved).exists():
                        alt = resolved.replace("docs/commands-legacy/", "docs/commands/")
                        if (docs_dir.parent / alt).exists():
                            resolved = alt
                        else:
                            alt2 = resolved.replace("docs/commands/", "docs/commands-legacy/")
                            if (docs_dir.parent / alt2).exists():
                                resolved = alt2
                    lines.append(f"- {cmd_name} — `{resolved}`\n")
                lines.append("\n")

    # Alphabetical full listing
    lines.append("## Alphabetical Listing\n\n")
    lines.append("| Command | File |\n")
    lines.append("|---------|------|\n")

    for fp in all_legacy:
        fm = parse_frontmatter(fp)
        title = fm.get("title", fp.stem.replace("-", " ").title())
        rel_path = relative_doc_path(fp, docs_dir)
        lines.append(f"| {title} | `{rel_path}` |\n")

    (output_dir / "legacy-commands-index.md").write_text("".join(lines), encoding="utf-8")
    print(f"  Generated legacy-commands-index.md ({len(all_legacy)} commands)")


def generate_all_categories_index(docs_dir: Path, output_dir: Path):
    """Generate all-categories-index.md — master navigation of all docs/."""
    lines = [HEADER, "# All Documentation Categories\n\n"]
    lines.append("> Master navigation index for the entire docs/ folder\n\n")
    lines.append("| Category | Path | Files | Description |\n")
    lines.append("|----------|------|-------|-------------|\n")

    descriptions = {
        "API": "Class reference documentation (Collection, Entity, DataClass, etc.)",
        "Admin": "Administration tools, CLI, data explorer, licenses, TLS",
        "Backup": "Backup and recovery procedures",
        "Concepts": "Foundational language concepts (variables, classes, types, flow control)",
        "Debugging": "Debugger, breakpoints, remote debugging",
        "Desktop": "Desktop/native application building",
        "Develop": "Development processes, explorer, field properties, triggers",
        "Develop-legacy": "Legacy development documentation",
        "Events": "Form and system events (On Clicked, On Load, On Timer, etc.)",
        "Extensions": "Plugin and extension development",
        "FormEditor": "Form design environment and properties",
        "FormObjects": "UI components (buttons, list boxes, inputs, dropdowns, etc.)",
        "GettingStarted": "Installation and quick start guides",
        "MSC": "Maintenance and Security Center tools",
        "Menus": "Menu system creation and management",
        "Notes": "Release notes and what's new",
        "ORDA": "Object-Relational Data Access architecture and patterns",
        "Preferences": "User preferences and application settings",
        "Project": "Project structure, architecture, compiler, components",
        "REST": "REST API endpoints ($filter, $orderby, $expand, etc.)",
        "ServerWindow": "Server-side UI and monitoring",
        "Tags": "Tag system documentation",
        "Users": "User management and authentication",
        "ViewPro": "Spreadsheet/ViewPro module",
        "WebServer": "Web server configuration, sessions, authentication, TLS",
        "WritePro": "Rich text editor module",
        "aikit": "AI integration toolkit and classes",
        "code-editor": "Code editor features and configuration",
        "commands": "Modern 4D command reference",
        "commands-legacy": "Legacy command documentation (1,200+ commands)",
        "settings": "Application and database settings",
        "assets": "Images and media assets (not documentation)",
    }

    dirs = sorted(
        [d for d in docs_dir.iterdir() if d.is_dir()],
        key=lambda d: d.name.lower()
    )

    for d in dirs:
        name = d.name
        count = count_files_recursive(d)
        desc = descriptions.get(name, "")
        lines.append(f"| {name} | `docs/{name}/` | {count} | {desc} |\n")

    (output_dir / "all-categories-index.md").write_text("".join(lines), encoding="utf-8")
    print(f"  Generated all-categories-index.md ({len(dirs)} categories)")


# ---------------------------------------------------------------------------
# Main
# ---------------------------------------------------------------------------

def main():
    parser = argparse.ArgumentParser(description="Generate documentation indexes")
    script_dir = Path(__file__).resolve().parent
    skill_dir = script_dir.parent

    parser.add_argument(
        "--docs-dir",
        type=Path,
        default=skill_dir / "docs",
        help="Path to docs/ directory",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=skill_dir / "references",
        help="Path to output references/ directory",
    )
    args = parser.parse_args()

    docs_dir = args.docs_dir.resolve()
    output_dir = args.output_dir.resolve()

    if not docs_dir.exists():
        print(f"Error: docs directory not found: {docs_dir}", file=sys.stderr)
        sys.exit(1)

    output_dir.mkdir(parents=True, exist_ok=True)

    print(f"Generating indexes from: {docs_dir}")
    print(f"Output directory: {output_dir}\n")

    # 1. API classes
    generate_api_index(docs_dir, output_dir)

    # 2. Commands (modern + themes)
    generate_commands_index(docs_dir, output_dir)

    # 3. Concepts
    generate_simple_index(
        docs_dir, output_dir,
        "Concepts", "concepts-index.md",
        "Language Concepts Index",
        "Foundational 4D language concepts"
    )

    # 4. ORDA
    generate_simple_index(
        docs_dir, output_dir,
        "ORDA", "orda-index.md",
        "ORDA Documentation Index",
        "Object-Relational Data Access architecture and patterns"
    )

    # 5. REST
    generate_simple_index(
        docs_dir, output_dir,
        "REST", "rest-index.md",
        "REST API Index",
        "REST API endpoints and configuration"
    )

    # 6. Events
    generate_simple_index(
        docs_dir, output_dir,
        "Events", "events-index.md",
        "Form & System Events Index",
        "All form and system events"
    )

    # 7. Form Objects
    generate_simple_index(
        docs_dir, output_dir,
        "FormObjects", "form-objects-index.md",
        "Form Objects Index",
        "UI components and their properties"
    )

    # 8. Web Server
    generate_simple_index(
        docs_dir, output_dir,
        "WebServer", "webserver-index.md",
        "Web Server Index",
        "Web server configuration, sessions, and request handling"
    )

    # 9. Legacy commands (organized by theme)
    generate_legacy_commands_index(docs_dir, output_dir)

    # 10. Master index of all categories
    generate_all_categories_index(docs_dir, output_dir)

    print(f"\nDone! Generated 10 index files in {output_dir}")


if __name__ == "__main__":
    main()
